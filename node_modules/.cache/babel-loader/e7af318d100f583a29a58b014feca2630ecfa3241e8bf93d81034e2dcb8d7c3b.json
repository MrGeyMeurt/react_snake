{"ast":null,"code":"const isIterable = obj => Symbol.iterator in obj;\nconst compareMapLike = (iterableA, iterableB) => {\n  const mapA = iterableA instanceof Map ? iterableA : new Map(iterableA);\n  const mapB = iterableB instanceof Map ? iterableB : new Map(iterableB);\n  if (mapA.size !== mapB.size) return false;\n  for (const [key, value] of mapA) {\n    if (!Object.is(value, mapB.get(key))) {\n      return false;\n    }\n  }\n  return true;\n};\nfunction shallow(objA, objB) {\n  if (Object.is(objA, objB)) {\n    return true;\n  }\n  if (typeof objA !== \"object\" || objA === null || typeof objB !== \"object\" || objB === null) {\n    return false;\n  }\n  if (isIterable(objA) && isIterable(objB)) {\n    const iteratorA = objA[Symbol.iterator]();\n    const iteratorB = objB[Symbol.iterator]();\n    let nextA = iteratorA.next();\n    let nextB = iteratorB.next();\n    if (Array.isArray(nextA.value) && Array.isArray(nextB.value) && nextA.value.length === 2 && nextB.value.length === 2) {\n      return compareMapLike(objA, objB);\n    }\n    while (!nextA.done && !nextB.done) {\n      if (!Object.is(nextA.value, nextB.value)) {\n        return false;\n      }\n      nextA = iteratorA.next();\n      nextB = iteratorB.next();\n    }\n    return !!nextA.done && !!nextB.done;\n  }\n  const keysA = Object.keys(objA);\n  if (keysA.length !== Object.keys(objB).length) {\n    return false;\n  }\n  for (const keyA of keysA) {\n    if (!Object.hasOwn(objB, keyA) || !Object.is(objA[keyA], objB[keyA])) {\n      return false;\n    }\n  }\n  return true;\n}\nexport { shallow };","map":{"version":3,"names":["isIterable","obj","Symbol","iterator","compareMapLike","iterableA","iterableB","mapA","Map","mapB","size","key","value","Object","is","get","shallow","objA","objB","iteratorA","iteratorB","nextA","next","nextB","Array","isArray","length","done","keysA","keys","keyA","hasOwn"],"sources":["C:/Users/manut/Documents/my-app/node_modules/zustand/esm/vanilla/shallow.mjs"],"sourcesContent":["const isIterable = (obj) => Symbol.iterator in obj;\nconst compareMapLike = (iterableA, iterableB) => {\n  const mapA = iterableA instanceof Map ? iterableA : new Map(iterableA);\n  const mapB = iterableB instanceof Map ? iterableB : new Map(iterableB);\n  if (mapA.size !== mapB.size) return false;\n  for (const [key, value] of mapA) {\n    if (!Object.is(value, mapB.get(key))) {\n      return false;\n    }\n  }\n  return true;\n};\nfunction shallow(objA, objB) {\n  if (Object.is(objA, objB)) {\n    return true;\n  }\n  if (typeof objA !== \"object\" || objA === null || typeof objB !== \"object\" || objB === null) {\n    return false;\n  }\n  if (isIterable(objA) && isIterable(objB)) {\n    const iteratorA = objA[Symbol.iterator]();\n    const iteratorB = objB[Symbol.iterator]();\n    let nextA = iteratorA.next();\n    let nextB = iteratorB.next();\n    if (Array.isArray(nextA.value) && Array.isArray(nextB.value) && nextA.value.length === 2 && nextB.value.length === 2) {\n      return compareMapLike(\n        objA,\n        objB\n      );\n    }\n    while (!nextA.done && !nextB.done) {\n      if (!Object.is(nextA.value, nextB.value)) {\n        return false;\n      }\n      nextA = iteratorA.next();\n      nextB = iteratorB.next();\n    }\n    return !!nextA.done && !!nextB.done;\n  }\n  const keysA = Object.keys(objA);\n  if (keysA.length !== Object.keys(objB).length) {\n    return false;\n  }\n  for (const keyA of keysA) {\n    if (!Object.hasOwn(objB, keyA) || !Object.is(objA[keyA], objB[keyA])) {\n      return false;\n    }\n  }\n  return true;\n}\n\nexport { shallow };\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}